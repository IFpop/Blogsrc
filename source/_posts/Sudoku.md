---
title: Sudoku
date: 2019-12-21 20:00:22
tags:
- python
categories:
	
---

# 项目链接

[数独项目仓库](<https://github.com/IFpop/Soduku>)

# PSP

> PSP是卡耐基梅隆大学（CMU）的专家们针对软件工程师所提出的一套模型：Personal Software Process (PSP， 个人开发流程，或称个体软件过程)。

## 时间安排表

| PSP2.1                                  | Personal Software Process stages        | 预估耗时(min) | 实际耗时(min) |
| :-------------------------------------- | :-------------------------------------- | ------------- | ------------- |
| Planning                                | 计划                                    | 60            | 60            |
| ·Estimate                               | ·估计这个任务需要多少时间               | 60*48         |               |
| Development                             | 开发                                    | 60*2          |               |
| · Analysis                              | · 需求分析 (包括学习新技术)             | 60*2          |               |
| · Design Spec                           | · 生成设计文档                          | 60            |               |
| · Design Review                         | · 设计复审                              | 60*2          |               |
| · Coding Standard                       | · 代码规范 (为目前的开发制定合适的规范) | 60            |               |
| · Design                                | · 具体设计                              | 60*3          |               |
| · Coding                                | · 具体编码                              | 60*4          |               |
| · Code Review                           | · 代码复审                              | 60*2          |               |
| · Test                                  | · 测试（自我测试，修改代码，提交修改）  | 60*4          |               |
| Reporting                               | 报告                                    | 60*3          |               |
| · Test Repor                            | · 测试报告                              | 60            |               |
| · Size Measurement                      | · 计算工作量                            | 60            |               |
| · Postmortem & Process Improvement Plan | · 事后总结, 并提出过程改进计划          | 60*2          |               |
|                                         | 合计                                    | 60*77         |               |

# 需求分析

- 生成终局

  - 在命令行中使用`-c`参数加数字`N(1≤N≤1000000)`控制生成数独终局的数量

    ```bash
    sudoku.exe -c N
    ```

  - 将生成的数独终局用一个文本文件(假设名字叫`sudoku.txt`)的形式保存起来，每次生成的txt文件需要覆盖上次生成的txt文件，文件内的格式如下，数与数之间由空格分开，终局与终局之间空一行，行末无空格

  - 程序在处理命令行参数时，不仅能处理格式正确的参数，还能处理各种异常的情况，如：

    > sudoku.exe -c abc

  - 在生成数独矩阵时，左上角的第一个数为：`(学号后两位相加)%9+1`。

- 求解数独

  - 在命令行中使用-s参数加文件名的形式求解数独，并将结果输出至文件，如：

    > sudoku.exe -s absolute_path_of_puzzlefile

    程序将从路径中读取数独题目，并将数独题目的一个可行解输出至`sudoku.exe`同目录的`sudoku.txt`，要求与生成终局相同。

  - 数独题目格式：其中0代表空格，题目与题目之间空一行，行末无空格，最后一个数独题目后无空行。

  - 数独题目个数`N(1≤N≤1000000)`，保证文件中的数独格式正确。

- 其他要求

  - 需要对代码进行一定的注释。
  - 要求程序在60s内给出结果。

# 解题思路

## 生成终局

### 方法

根据题述要求，先确定如何生成终局。通过网上查资料，得到如下方法：

- 回溯法

  > 从数独的左上角(0,0)处开始，生成随机数，然后依次从左往右、从上往下，在某一步生成1-9的数字均不能满足数独要求的时候需要退回到上一个状态重新生成其他可能的解，如此直至最终拼成完整的数独地图。



![1576601025276](1576601025276.png)

- 以宫为单位的矩阵置换法

  > - 第一步：先在第五宫填完一个满足数独要求的9个数字
  >
  > ![1576630672896](1576630672896.png)
  >
  > - 第二步：将第五宫内容通过行变换放置到左边和右边的两个九宫格
  >
  > ![1576630770056](1576630770056.png)
  >
  > - 第三步：将第五宫的九宫格内容通过列变换放置上边和下边的两个九宫格
  >
  > ![1576630843295](1576630843295.png)
  >
  > - 第四步：将第4宫的九宫格内容通过列变换放置到上边和下边的两个九宫格，将第6宫的九宫格内容也通过列变换放置到上边和下边的两个九宫格。
  >
  > ![1576630882421](1576630882421.png)

- 模板数字替换法

  > 事先准备好一个符合要求的数独终局模板，模板中的元素为字母a~i，然后随机生成一串包含1-9的数字序列，将字母一一对应，替换为数字，获得数独终局。

- 数列法

  > 生成一个数列，然后将此数列分别向右移动0、3、6、1、4、7、2、5、8位得到终局第一到第九行。可以将第1~3行对应的移动位数改变一下顺序，如改为0、6、3，就可以得到一个新终局。此外，4到6，7到9行也可以更改。于是一个数列可以生成$ 6^3=216 $个终局，数字1到9可以生成9！= 362880个数列。

### 选取

​	分性上述方法，回溯法生成的数独终局随机性非常高，但是效率相对较低，想要达到题目要求需要消耗大量时间和计算机资源；以宫为单位的矩阵置换法，通过矩阵行列变换有2!×3!×3!×2!×3!×3!=5184，要想生成1000000个终局，中间的九宫格就需要1000000/5184=192，而正中九宫格有8!=40320个足够满足要求，但由于需要控制多个九宫格进行矩阵变换，还是较为复杂；模板数字替换法效率较高，但是如果只使用一个模板的话，最多能生成的不同的数独终局数仅为9！=362880，而本项目中规定数独终局的第一行第一列为定值，使一个模板能生成的不同的数独终局数为8！=40320，显然是远远无法达到题目要求的数量上限（N<=1000000）。对于数列法，不仅高效，生成的终局数量达到目标要求，而且操作简单而快速，但终局相差不多。

​	最终权衡，我决定使用方法四——数列法，来产生最终的数独终局。由于实验要求左上角的数字是`(学号后两位相加)%9+1`,所以生成数列时先固定好第一位数字，剩下的8位数字全排列8!也就是约为40000，是要求最大的终局数为1000000，所以最终一个排列需要1000000/40000 = 25，也就是每种排列需要生成25个终局。本实验中每种排列生成30个终局。

## 求解数独

### 方法

- 递归回溯法

  > 1. 如果全部填完，那么该数独的这种填法就是其中一种解，输出该数独解。
  > 2. 如果还没填完，填到了第x，y位置，判断该位置是否有数字（原题该位置有就有，没有就没有），如果有，填下一个位置。如果没有，寻找1-9数字在三个flag中为0的数字。找到了，标记flag（3个）为1，填下一个位置。
  > 3. 回溯法是恢复之前的flag和数据，即恢复为0，因此，每次填完数字，即在尝试该数据填完后，恢复flag和原来的数独数字

- 排除候选猜测法

  > 1. 传入数独矩阵，确定的数字直接填到对应的坐标上，没有填上数字的坐标可能候选值是1~9，再根据确定的值排除候选值。
  > 2. 当通过一般数独规则将候选值排除完，若答案仍不能确定，那么就开始进行点的猜测。
  > 3. 知道所有框中的数字都是确定的，就将其输出。

### 选取

- ​	最终综合考虑，当遇到困难级别的数独时，排除候选猜测法的效率是要高于递归回溯法。

  ​	下列是我的测试结果：

  ```python
  8 0 0 0 0 0 0 0 0
  0 0 3 6 0 0 0 0 0
  0 7 0 0 9 0 2 0 0
  0 5 0 0 0 7 0 0 0
  0 0 0 0 4 5 7 0 0
  0 0 0 1 0 0 0 3 0
  0 0 1 0 0 0 0 6 8
  0 0 8 5 0 0 0 1 0
  0 9 0 0 0 0 4 0 0
  
  排除候选测试法：0.0100 seconds
  递归回溯法：    0.1262 seconds
  ```

  ​	最终决定选取排除候选测试法。

# 设计实现过程

## 模块介绍

### 主控模块

```python
'''
根据参数调用下列函数进行相应处理（包括参数合法性判断）
'''
```

### 生成终局模块

- 数列法

```python
1. 确定一个初始数列。
2. 由当前数列生成全排列中的一种。
3. 由上述得到的排列，按照之前所说原则进行移动操作，最终生成一个终局。
4. 检查生辰的终局数是否达到要求，如果没有达到，则返回第3步。
```

- 代码组织

```python
'''
终局生成类：
移动变换元组、求解下一个全排列函数、初始化函数
'''
```

### 数独求解

- 排除候选法

```python
#这里之后补充完整的算法思路
```

- 代码组织

```python
'''
数独求解类：
初始化函数、记录函数、检错函数、回溯函数、估值函数、排除侯选数函数、深度优先遍历
'''
```

## 思路流程图

![1577256535140](1577256535140.png)



# 性能分析及优化

### 生成终局部分性能分析及优化

- 执行命令

  ```python
  python3 sudoku.py -c 1000000
  ```

  | 语言   | 生成1000000个终局所耗时间 |
  | ------ | ------------------------- |
  | python | 30.9375                   |
  | c/c++  | 2.4605                    |

  

- 模块时间分布

  > 使用【调试】中的启动python分析得到

  ![1577338561803](1577338561803.png)

  由图中分析可以知道占用时间主要集中于`__init__`和`create`。

- 函数时间分布

  ![1577338458758](1577338458758.png)

  时间消耗主要集中于`write2file`函数以及`get_sudoku`函数中。

- 时间分布图

  ```python
  #为了能够更加直观的看出那个模块以及函数的时间消耗，增加了利用cprofile(分析时间）以及gprof2dot（可视化）
  #参考文献进行了性能分析: https://zhuanlan.zhihu.com/p/24495603
  ```

  ![1](1.png)

此处可以看出`replace`切割相对于其他比较耗时。

- 原因分析及解决方案

  ​	首先是`write2file`以及`get_sudoku`函数，最开始的思路是得到一个终局写入一次，但事实证明效率极低，目前采用的策略是将全部的数独存到一个`list`变量`perm`中，最后集中写入。而`replace`比较耗时，这是因为`python`本身的特性决定的，`python`是一种解释性语言，前期的编译是将 `Python` 代码编译成解释器可以理解的中间代码，解释器再将中间代码翻译成` CPU `可以理解的指令,相比于 AOT(提前编译型语言，比如C)直接编译成机器码，肯定是慢的。那么要怎样才能使用`python`到达`c`的速度呢?由此我决定使用`cython`(一种C语言与python的结合体)写数独过程。学习过程参看[博客](<https://blog.csdn.net/Pythoncxy/article/details/98060530>)。

  ​	另外，生成全排列的函数`nextPermutation`，采取的措施是每次遍历完30个`move_way`之后才会获取下一个全排列，大大增加了该函数的调用次数，也浪费了时间。由此，我之后采用先将所有的全排列生成然后存储起来，之后直接访问即可。

  ​	最后就是文件写入函数也会有占用大量时间，目前采用的策略是对于每一个数独，逐个写入，这样会多次调用`write`函数，所以最终的方案是建立一个缓存区，将数独以字符串形式存入，最后一起写入。结合`cython`，可以使用更快的`fputs`进行一次性写入。

- 最终结果

  ```python
  #执行下列命令
  python3 sudoku.py -c 1000000
  ```


| 语言           | 生成1000000个终局所耗时间 |
| -------------- | ------------------------- |
| python(最开始) | 30.9375                   |
| c/c++          | 2.4605                    |
| cython         | 2.6758                    |



## 解数独性能及优化

